<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Vrecan...</title>
    <link>http://vrecan.github.io/post/</link>
    <description>Recent content in Posts on Vrecan...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Mar 2015 20:23:05 -0600</lastBuildDate>
    <atom:link href="http://vrecan.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Managing Application Shutdown in Go</title>
      <link>http://vrecan.github.io/post/golang_shutdown/</link>
      <pubDate>Tue, 10 Mar 2015 20:23:05 -0600</pubDate>
      
      <guid>http://vrecan.github.io/post/golang_shutdown/</guid>
      <description>

&lt;h3 id=&#34;overview:a3f014005cf18d6d375bffc268e2748e&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;I was looking around and couldn&amp;rsquo;t find a simple library that would manage application shutdown using signals. I decided to build a simple library to handle application shutdown and calling Close methods on structs when shutdown was signaled. It is called &lt;a href=&#34;http://github.com/vrecan/death&#34; title=&#34;Application shutdown library for golang&#34;&gt;death&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;requirements:a3f014005cf18d6d375bffc268e2748e&#34;&gt;Requirements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Should only need to pass the signals you want to use for shutdown.&lt;/li&gt;
&lt;li&gt;Block the application from shutting down until signal was recieved.&lt;/li&gt;
&lt;li&gt;Optionally pass structs with a Close method to cleanup objects when shutdown is signaled.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-do-you-use-it:a3f014005cf18d6d375bffc268e2748e&#34;&gt;How do you use it?&lt;/h3&gt;

&lt;p&gt;Import death and syscall so that you can pass the signals you want to shutdown with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    DEATH &amp;quot;github.com/vrecan/death&amp;quot;
    SYS &amp;quot;syscall&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a death struct with the signals we want to use for shutdown.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    death := DEATH.NewDeath(SYS.SIGINT, SYS.SIGTERM)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we are doing setting up everything in our application we can then call WaitForDeath() to block our application from shutting down.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    death.WaitForDeath()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also have death automically close structs for you when shutdown is triggered. Create a slice to contain all the items you want to call Close().&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objects := make([]DEATH.Closable, 0)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your structs just need a Close() method to implement the Closable interface&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type NewType struct {
}

func (n *NewType) Close() {
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once your go routine(s) have been started append them to the slice.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    objects = append(objects, &amp;amp;NewType{})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now just pass them in when you are going to call WaitForDeath()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    death.WaitForDeath(objects...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also pass them in one by one if you prefer&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;death.WaitForDeath(object1, object2, object3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update:a3f014005cf18d6d375bffc268e2748e&#34;&gt;&lt;strong&gt;&lt;em&gt;Update&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;The newest version now does closing of objects in parallel with a timeout. This allows you to limit how long you are willing to wait for shutdown of all your objects. Because they are in parallel this is the total time you are willing to wait and not per object.&lt;/p&gt;

&lt;h3 id=&#34;summary:a3f014005cf18d6d375bffc268e2748e&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m actually pretty happy with this library. It does everything I need it to do and has been really useful to just drop in and have solid shutdown management. It does currently use seelog to log a few things this could easily be removed. All of our applications use seelog for application logs but I would love to hear if there are any good ideas about managing logging inside of libraries. I&amp;rsquo;ve thought about having the ablilty to pass in a logger with an interface but I would like to hear how other people deal with this.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/vrecan/death&#34; title=&#34;Application shutdown library for golang&#34;&gt;Managing death in go&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compiling ZeroMQ for Windows in Centos 7</title>
      <link>http://vrecan.github.io/post/crosscompile_go_zeromq/</link>
      <pubDate>Mon, 02 Mar 2015 20:29:34 -0700</pubDate>
      
      <guid>http://vrecan.github.io/post/crosscompile_go_zeromq/</guid>
      <description>&lt;p&gt;I&#39;ve found it really dificult to find a concrete tutorial for building zeromq for go in windows using MinGW in centos 7. First lets add the epel-release repo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install epel-release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets install mingw64. For this tutorial I am going to just install all the mingw libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install mingw64*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; Now lets download and compile zeromq using mingw.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://download.zeromq.org/zeromq-4.0.5.zip
unzip zeromq-4.0.5.zip ~/zeromq
cd ~/zeromq
mingw64-configure configure
mingw64-make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets recompile go so that it is also using the mingw compiler.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local/go/src
sudo  env CGO_ENABLED=1 GOOS=windows GOARCH=amd64 CC_FOR_TARGET=&amp;quot;x86_64-w64-mingw32-gcc&amp;quot; ./make.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets move to the go project that you are going to be using with zeromq.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd &amp;lt;PROJECT DIR&amp;gt;
env CGO_ENABLED=1 GOOS=windows GOARCH=amd64 CC_FOR_TARGET=&amp;quot;x86_64-w64-mingw32-gcc&amp;quot; CGO_LDFLAGS=&amp;quot;-L/home/&amp;lt;username&amp;gt;/zeromq/src/.libs -static-libgcc&amp;quot; go build -v -x  -o app.exe
minigw_bin=/usr/x86_64-w64-mingw32/sys-root/mingw/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should have created an exe binary that is linked to the mingw dll&#39;s and your recently compiled version of zeromq. Now lets copy the dll&#39;s for the required libraries to the current directory so that we can package this up and put it on a windows box.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp $minigw_bin/libwinpthread-1.dll .
cp $minigw_bin/libgcc_s_seh-1.dll .
cp $minigw_bin/libstdc++-6.dll .
cp ~/zeromq/src/.libs/libzmq.dll .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;p&gt; If you now transfer this folder to a windows(64) 7/8/8.1 box you can now just execute the .exe and have a working go windows application using zeromq.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Dependency Management</title>
      <link>http://vrecan.github.io/post/godep/</link>
      <pubDate>Sun, 01 Mar 2015 20:38:08 -0700</pubDate>
      
      <guid>http://vrecan.github.io/post/godep/</guid>
      <description>

&lt;p&gt;Godeps is a nice simple tool that allows you to manage dependencies in a very easy way. One major drawback though is that it requires you to commit your dependencies into your repository. This is great for simplicity but horrible for code review. Seeing a commit with 26k files changed really makes it hard to review.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve found a simple solution to the problem if you use the common go import layout&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-- github.com
|   +-- company
|   |   +-- project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you follow this layout then you can easily extract all your deps into their own repo like so.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd github.com/company
godep save ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will Recursively grab your dependencies that are not in this path and put them in a godeps folder at the company depth. Now add the contents of the new Godeps folder into a new repo with the name Godeps. &lt;/p&gt;

&lt;h2 id=&#34;building-with-new-dependencies:8a18e8b20bd4ceba8c6e1d3df562deeb&#34;&gt;Building with new dependencies&lt;/h2&gt;

&lt;p&gt;Now that you have dependencies in their own repo you can add Godeps to your .gitignore for all your other repos and pull them down locally.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd github.com/company/project
git clone github.com/company/Godeps
godep go buld
godep go test ./... --race
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion-drawbacks:8a18e8b20bd4ceba8c6e1d3df562deeb&#34;&gt;Conclusion / Drawbacks&lt;/h2&gt;

&lt;p&gt;
This works great if you are ok with taking the master branch versions of all your own software. This might not work for everyone but with my workflow this seems to give us the best of both worlds. Easy third party library management and go getable software for all of our repos. This also has the added benefit that we no longer have to remember to update godep everytime we make an internal library change, in our workflow everything in master should be buildable together.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>